/*
 * generated by Xtext 2.12.0
 */
package fr.idmteam1.idmproject.dronedsl.validation

import fr.idmteam1.idmproject.dronedsl.droneDSLLib.DroneDSLLibPackage
import fr.idmteam1.idmproject.dronedsl.droneDSLLib.FonctionCallInterne
import fr.idmteam1.idmproject.dronedsl.droneDSLLib.FonctionDecl
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map.Entry
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType

import static extension org.eclipse.xtext.EcoreUtil2.*
import fr.idmteam1.idmproject.dronedsl.droneDSLLib.LibName

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DroneDSLLibValidator extends AbstractDroneDSLLibValidator {
	
	public static val CYCLE_ERR = "recursionDetected"
	public static val CYCLE_MSG = "Erreur: recursion non autorisée"
	public static val LIBNAME_ERR = "libNameNotMatching"
	public static val LIBNAME_MSG = "Erreur: le nom de la lib et le nom de fichier doivent être identiques"
	
	private static var inMain = false
	private static var actualFunc = ""
	private static var map = new HashMap
	
	private var cycleDetected = true
	private Object cycleTestLock = new Object()
	
	/*@Check(CheckType.FAST)
	def checkLibName(LibName libName) {
		val fileName = libName.eResource.normalizedURI.trimFileExtension.lastSegment
		if(!fileName.equals(libName.name)) {
			println("filename and lib name are different: filename: " + fileName + " libname: " + libName.name)
			error(LIBNAME_MSG, DroneDSLLibPackage.Literals.LIB_NAME__NAME, LIBNAME_ERR)
		}
	}*/
	
	@Check(CheckType.FAST)
	def checkFunctionDecl(FonctionDecl decl) {
//		println(decl.name)
		actualFunc =  decl.name
		map.put(actualFunc, new ArrayList)
	}
	
	@Check(CheckType.FAST)
	def validFunctionCall(FonctionCallInterne call) {
		synchronized(cycleTestLock) {
			cycleDetected = true
			if(!inMain){
				if(!actualFunc.equals(call.ref.name)){
					(map.get(actualFunc) as List<Object>).add(call.ref.name)
					printMap()
					cycleDetected = checkCycle()
				}
				else{
					println("ERREUR DE CYCLE")
					cycleDetected = true
					error(CYCLE_MSG, DroneDSLLibPackage.Literals.FONCTION_CALL_INTERNE__REF, CYCLE_ERR)
				}
			}
		}
	}
	
	def printMap() {
		var set = map.entrySet();
		var iterator = set.iterator();
		while(iterator.hasNext()) {
			var mentry = iterator.next() as Entry<Object, Object>;
			System.out.print("key is: "+ mentry.getKey() + " & Value is: ");
			System.out.println(mentry.getValue());
		}
	}
	
	/**
	 * Parcourt la map, pour chaque element de la liste de la clef en cours d'analyse (key)
	 * on verifie le cycle via la fonction checkCycleProfond
	 */
	def Boolean checkCycle() {
		var set = map.entrySet();
		var iterator = set.iterator();
		// Clef en cours d'analyse
		var key = ""
		
		// Parcourt de la map
		while(iterator.hasNext()) {
			// Recuperer l'iterator
			var mentry = iterator.next() as Entry<Object, Object>;
			// Recuperer la clef en cours d'analyse
			key = mentry.getKey() as String
			// Recuperer la liste des fonctions qu'elle appelle
			var funcCallList = mentry.getValue() as List<Object>
			// cf ci-dessous
			if(checkCycleProfond(key, funcCallList))
				return true
		}
		return false
	}
	
	/**
	 * Alors la c'est chaud.
	 * @param funcCallList c'est la liste des fonctions appelees par la fonction de nom key
	 * 
	 */
	def Boolean checkCycleProfond(String key, List<Object> funcCallList) {
		// fonction en cours d'analyse
		var func = ""
		
		// Parcourt la liste des fonctions appelees par key
		for(var i = 0; i < funcCallList.size; i++) {
				// On recupere la fonction appelee
				func = funcCallList.get(i) as String
				// On recupere la liste des fonctions appelee par cette fonction
				var list = map.get(func) as List<Object>
				
				// Parcourt de cette liste
				for(var j = 0; j < list.size; j++) {
					
					// Si elle appelle la fonction key (recursion croisee) c'est mort
					// @TODO : Faire error(...)
					if((list.get(j) as String).equals(key as String)) {
						println("ERREUR DE CYCLE")
						error(CYCLE_MSG, DroneDSLLibPackage.Literals.FONCTION_CALL_INTERNE__REF, CYCLE_ERR)
						cycleDetected = true
						return true
					// Sinon il faut faire un appel recursif la complexite est ouf mais ca passe
					} else {
						// On recupere la fonctions appelee
						var func2 = list.get(j) as String
						// Evite de boucler sur soit meme
						if(!func2.equals(key)) {
							// Et c'est reparti
							var list2 = map.get(func2) as List<Object>
							if(checkCycleProfond(key, list2))
								return true
						}
					}
			}
		}
		return false
	}
	
}
