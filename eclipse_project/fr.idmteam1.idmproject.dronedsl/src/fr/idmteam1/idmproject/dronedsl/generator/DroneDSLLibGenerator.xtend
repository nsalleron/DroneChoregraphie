/*
 * generated by Xtext 2.12.0
 */
package fr.idmteam1.idmproject.dronedsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import fr.idmteam1.idmproject.dronedsl.droneDSLLib.Model
import fr.idmteam1.idmproject.dronedsl.droneDSLLib.FonctionDecl

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DroneDSLLibGenerator extends AbstractGenerator {

	val stubFilesMap = newLinkedHashMap(
		"../src/fr/roboticiens/body/BodyInstruction.java" -> contentBodyInstructionClass(),
		"../src/fr/roboticiens/commandes/Atterrir.java" -> contentAtterrirClass(),
		"../src/fr/roboticiens/commandes/Avancer.java" -> contentAvancerClass(),
		"../src/fr/roboticiens/commandes/CommandeAvecDureeVitesse.java" -> contentCommandeAvecDureeVitesseClass(),
		"../src/fr/roboticiens/commandes/CommandeBasique.java" -> contentCommandeBasiqueClass(),
		"../src/fr/roboticiens/commandes/CommandeParallelisable.java" -> contentCommandeParallelisableClass(),
		"../src/fr/roboticiens/commandes/Decoller.java" -> contentDecollerClass(),
		"../src/fr/roboticiens/commandes/Descendre.java" -> contentDescendreClass(),
		"../src/fr/roboticiens/commandes/Droite.java" -> contentDroiteClass(),
		"../src/fr/roboticiens/commandes/Gauche.java" -> contentGaucheClass(),
		"../src/fr/roboticiens/commandes/Monter.java" -> contentMonterClass(),
		"../src/fr/roboticiens/commandes/Pause.java" -> contentPauseClass(),
		"../src/fr/roboticiens/commandes/Reculer.java" -> contentReculerClass(),
		"../src/fr/roboticiens/commandes/RotationDroite.java" -> contentRotationDroiteClass(),
		"../src/fr/roboticiens/commandes/RotationGauche.java" -> contentRotationGaucheClass(),
		"../src/fr/roboticiens/imports/Import.java" -> contentImportClass(),
		"../src/fr/roboticiens/paralleles/Parallele.java" -> contentParalleleClass(),
		"../src/fr/roboticiens/prologue/Prologue.java" -> contentPrologueClass(),
		"../src/fr/roboticiens/types/Pourcent.java" -> contentPourcentClass(),
		"../src/fr/roboticiens/types/Seconde.java" -> contentSecondeClass(),
		"../src/fr/roboticiens/runtime/DroneRuntime.java" -> contentDroneRuntimeClass(),
		"../src/fr/roboticiens/runtime/DroneRuntimeExecutable.java" -> contentDroneRuntimeExecutableClass(),
		"../src/fr/roboticiens/runtime/ParrotDroneRuntime.java" -> contentDroneRuntimePrintClass()
	)
	
	val packagePath = "../src/fr/roboticiens/"
	
	override doGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {

		if(!input.allContents.toIterable.filter(Model).empty) {
			generateStubFiles(fsa)
			
			for (m : input.allContents.toIterable.filter(Model)) {
				val libName = input.URI.trimFileExtension.lastSegment
				val capitalizedFileName = libName.toFirstUpper
				val filename = packagePath + capitalizedFileName + ".java"
				fsa.generateFile(filename, m.compile)
			}
		}
	}
	
	def generateStubFiles(IFileSystemAccess2 fsa) {
		var itr = stubFilesMap.entrySet().iterator();
		while(itr.hasNext()) {
			var entry = itr.next()
			var filepath = entry.key
			var content = entry.value
			fsa.generateFile(filepath, content)
		}
	}
	
	def compile(Model e) 
		''' 
		package fr.roboticiens;
				
		import fr.roboticiens.commandes.*;
		import fr.roboticiens.paralleles.*;
		import fr.roboticiens.runtime.*;
		import fr.roboticiens.types.*;
				
		public class «e.eResource.URI.trimFileExtension.lastSegment.toFirstUpper» {
			
			«IF e.fonctions!== null»
    			« FOR f:e.fonctions»
	                 «f.compile»
	            «ENDFOR»
	       «ENDIF»
			
		}
        '''
        
    def compile(FonctionDecl e)
    	'''
		public static void «e.name»(DroneRuntime runtime) {
			« FOR f:e.body»
			         «f.toString»
			«ENDFOR»
			
		}
    	'''

	def contentDroneRuntimePrintClass() {
		'''
		package fr.roboticiens.runtime;
		
		import java.io.BufferedReader;
		import java.io.BufferedWriter;
		import java.io.IOException;
		import java.io.InputStream;
		import java.io.InputStreamReader;
		import java.io.OutputStream;
		import java.io.OutputStreamWriter;
		import java.lang.ProcessBuilder.Redirect;
		import java.util.ArrayList;
		import java.util.Iterator;
		import java.util.List;
		import java.util.Set;
		import java.util.concurrent.TimeUnit;
		import java.util.concurrent.locks.Condition;
		import java.util.concurrent.locks.Lock;
		import java.util.concurrent.locks.ReentrantLock;
		
		import fr.roboticiens.commandes.Atterrir;
		import fr.roboticiens.commandes.Avancer;
		import fr.roboticiens.commandes.CommandeAvecDureeVitesse;
		import fr.roboticiens.commandes.CommandeParallelisable;
		import fr.roboticiens.commandes.Decoller;
		import fr.roboticiens.commandes.Descendre;
		import fr.roboticiens.commandes.Droite;
		import fr.roboticiens.commandes.Gauche;
		import fr.roboticiens.commandes.Monter;
		import fr.roboticiens.commandes.Pause;
		import fr.roboticiens.commandes.Reculer;
		import fr.roboticiens.commandes.RotationDroite;
		import fr.roboticiens.commandes.RotationGauche;
		import fr.roboticiens.paralleles.Parallele;
		import fr.roboticiens.prologue.Prologue;
		import fr.roboticiens.types.Pourcent;
		
		public class ParrotDroneRuntime implements DroneRuntime {
		
			public static final int DECOLLER_INPUT_CODE = 1;
			public static final int ATTERRIR_INPUT_CODE = 2;
			public static final int AVANCER_INPUT_CODE = 3;
			public static final int RECULER_INPUT_CODE = 4;
			public static final int MONTER_INPUT_CODE = 5;
			public static final int DESCENDRE_INPUT_CODE = 6;
			public static final int GAUCHE_INPUT_CODE = 7;
			public static final int DROITE_INPUT_CODE = 8;
			public static final int ROTATION_GAUCHE_INPUT_CODE = 9;
			public static final int ROTATION_DROITE_INPUT_CODE = 10;
			
			public static final int ELOIGNEMENT_MAX_CODE = 11;
			public static final int HAUTEUR_MAX_CODE = 12;
			public static final int VIT_DEPLACEMENT_MAX_CODE = 13;
			public static final int VIT_HAUTEUR_MAX_CODE = 14;
			public static final int VIT_ROTATION_MAX_CODE = 15;
			public static final int QUIT = 16;
			
			public static final String STATE_STARTED = "STARTED";
			public static final String STATE_FLYING = "FLYING";
			public static final String STATE_LANDED = "LANDED";
			public static final String STATE_STOPPED = "STOPPED";
			
			private static final int ANGLE_ROLL_PICH_MAX = 35; // degre
			private static final int VITESSE_VERTICAL_MAX = 6; // m/s
			private static final int ANGLE_ROTATION_MAX = 200; // degre
			
			public enum DroneState {
				STARTED, FLYING, LANDED, STOPPED
			}
			
			private ProcessBuilder processBuilder;
			private Process process;
			
			private InputStream input;
			private OutputStream output;
			private BufferedReader brInput;
			private BufferedWriter bwOutput;
			private Object bwOutputLock = new Object();
			
			private Thread printerThread;
			
			private DroneState droneState = DroneState.STOPPED;
			private final Lock lockState = new ReentrantLock();
			private final Condition hasTakenOff = lockState.newCondition();
			private final Condition hasLanded = lockState.newCondition();
			private final Condition hasStarted = lockState.newCondition();
			private final Condition hasStopped = lockState.newCondition();
			
			public  ParrotDroneRuntime(final String parrotExecutablePath) {
				this.processBuilder = new ProcessBuilder(parrotExecutablePath);
				this.processBuilder.redirectError(Redirect.INHERIT);
			}
			
			@Override
			public void start(){
				 
				try{
					process = processBuilder.start();
					this.input = process.getInputStream();
				 	this.output = process.getOutputStream();
				 
				 	this.brInput = new BufferedReader(new InputStreamReader(input));
				 	this.bwOutput = new BufferedWriter(new OutputStreamWriter(output));
				 
				 	this.printerThread = new Thread(new Runnable() {
					 
					@Override
					public void run() {
						String line = null;
						try {
							while((line = brInput.readLine()) != null) {
								System.out.println("INPUT : " +line);
								if(line.equals(STATE_STARTED)) {
									droneState = DroneState.STARTED;
									lockState.lock();
									try {
										hasStarted.signalAll();
									} finally {
										lockState.unlock();
									}
								} else if(line.equals(STATE_FLYING)) {
									droneState = DroneState.FLYING;
									lockState.lock();
									try {
										hasTakenOff.signalAll();
									} finally {
										lockState.unlock();
									}
								} else if(line.equals(STATE_LANDED)) {
									droneState = DroneState.LANDED;
									lockState.lock();
									try {
										hasLanded.signalAll();
									} finally {
										lockState.unlock();
									}
								} else if(line.equals(STATE_STOPPED)) {
									droneState = DroneState.STOPPED;
									lockState.lock();
									try {
										hasStopped.signalAll();
									} finally {
										lockState.unlock();
									}
								} else {
									System.out.println(line);
								}
							} // fin while(readLine)
							
						} catch (IOException e) {
							return;
						}
					}
				 });
				 this.printerThread.start();
				}catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execPrologue(Prologue p) {
				try {
					// enregistrement des pourcentages de vitesse pour les utiliser avec le param√®tre de vitesse des mouvements
		
					int vitesseDeplacementMax = (int) Math.ceil((p.getVitesseDeplacement().getValue() / 100.0) * ANGLE_ROLL_PICH_MAX); //35 Max
					int vitesseVerticaleMax = (int) Math.ceil((p.getVitesseVerticale().getValue() / 100.0) * VITESSE_VERTICAL_MAX);	//6 metres Max
					int vitesseRotationMax = (int) Math.ceil((p.getVitesseRotation().getValue() / 100.0) * ANGLE_ROTATION_MAX);	//200 Max
					
					writeToSubProcessStdin(ELOIGNEMENT_MAX_CODE, p.getEloignementMax(), true);
					writeToSubProcessStdin(HAUTEUR_MAX_CODE, p.getHauteurMax(), true);
					writeToSubProcessStdin(VIT_DEPLACEMENT_MAX_CODE, vitesseDeplacementMax, true);
					writeToSubProcessStdin(VIT_HAUTEUR_MAX_CODE, vitesseVerticaleMax, true);
					writeToSubProcessStdin(VIT_ROTATION_MAX_CODE, vitesseRotationMax, true);
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execDecoller(Decoller d) {
				try {
					lockState.lock();
					while(droneState == DroneState.STOPPED) {
						hasStarted.await();
					}
					writeToSubProcessStdin(DECOLLER_INPUT_CODE, 0, true);
					// attendre que le drone reponde qu'il a bien decolle
					while(droneState != DroneState.FLYING) {
						hasTakenOff.await();
					}
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				} finally {
					lockState.unlock();
				}
			}
		
			@Override
			public void execAtterrir(Atterrir a) {
				try {
					lockState.lock();
					writeToSubProcessStdin(ATTERRIR_INPUT_CODE, 0, true);
					// attendre que le drone reponde qu'il a bien atterri
					while(droneState != DroneState.LANDED) {
						hasLanded.await();
					}
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				} finally {
					lockState.unlock();
				}
			}
		
			@Override
			public void execAvancer(Avancer a) {
				try {
					writeToSubProcessStdin(AVANCER_INPUT_CODE, a.getVitesse().getValue(), true);
					Thread.sleep(a.getDuree().getValue() * 1000);
					writeToSubProcessStdin(AVANCER_INPUT_CODE, 0, true);
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execReculer(Reculer r) {
				try {
					writeToSubProcessStdin(RECULER_INPUT_CODE, r.getVitesse().getValue() , true);
					Thread.sleep(r.getDuree().getValue() * 1000);
					writeToSubProcessStdin(RECULER_INPUT_CODE, 0, true);
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execMonter(Monter m) {
				try {
					writeToSubProcessStdin(MONTER_INPUT_CODE, m.getVitesse().getValue(), true);
					Thread.sleep(m.getDuree().getValue() * 1000);
					writeToSubProcessStdin(MONTER_INPUT_CODE, 0, true);
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execDescendre(Descendre d) {
				try {
					writeToSubProcessStdin(DESCENDRE_INPUT_CODE, d.getVitesse().getValue(), true);
					Thread.sleep(d.getDuree().getValue() * 1000);
					writeToSubProcessStdin(DESCENDRE_INPUT_CODE, 0, true);
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execGauche(Gauche g) {
				try {
					writeToSubProcessStdin(GAUCHE_INPUT_CODE, g.getVitesse().getValue(), true);
					Thread.sleep(g.getDuree().getValue() * 1000);
					writeToSubProcessStdin(GAUCHE_INPUT_CODE, 0, true);
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execDroite(Droite d) {
				try {
					writeToSubProcessStdin(DROITE_INPUT_CODE, d.getVitesse().getValue(), true);
					Thread.sleep(d.getDuree().getValue() * 1000);
					writeToSubProcessStdin(DROITE_INPUT_CODE, 0, true);
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execRotationGauche(RotationGauche rg) {
				try {
					writeToSubProcessStdin(ROTATION_GAUCHE_INPUT_CODE, rg.getVitesse().getValue(), true);
					Thread.sleep(rg.getDuree().getValue() * 1000);
					writeToSubProcessStdin(ROTATION_GAUCHE_INPUT_CODE, 0, true);
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execRotationDroite(RotationDroite rd) {
				try {
					writeToSubProcessStdin(ROTATION_DROITE_INPUT_CODE, rd.getVitesse().getValue(), true);
					Thread.sleep(rd.getDuree().getValue() * 1000);
					writeToSubProcessStdin(ROTATION_DROITE_INPUT_CODE, 0, true);
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
		
			@Override
			public void execPause(Pause p) {
				try {
					Thread.sleep(p.getDuree().getValue() * 1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
			
			@Override
			public void quit() {
				try {
					lockState.lock();
					writeToSubProcessStdin(QUIT, 0, true);
					while(droneState != DroneState.STOPPED) {
						hasStopped.await();
					}
					boolean terminated = process.waitFor(10, TimeUnit.SECONDS);
					printerThread.interrupt();
					if(!terminated) {
						process.destroy();
					}
					
				} catch (IOException e) {
					e.printStackTrace();
					System.exit(-1);
				} catch (InterruptedException e) {
					e.printStackTrace();
					System.exit(-1);;
				} finally {
					lockState.unlock();
				}
			}
		
			@Override
			public void execParallele(Parallele p) {
				List<Thread> threads = new ArrayList<Thread>();
				Set<CommandeParallelisable> commandes = p.getCommandes();
				
				try {
						
					for (Iterator<CommandeParallelisable> cmdItr = commandes.iterator(); cmdItr.hasNext();) {
						CommandeParallelisable commande = cmdItr.next();
						if(commande instanceof CommandeAvecDureeVitesse) {
							CommandeAvecDureeVitesse cmdDureeVitesse = CommandeAvecDureeVitesse.class.cast(commande);
							
							final CommandeAvecDureeVitesse cmdSend = cmdDureeVitesse;
							final CommandeParallelisable cmdPaSend = commande;
							threads.add(new Thread(new Runnable() {
													
									@Override
									public void run() {
										try {
											Thread.sleep(cmdSend.getDuree().getValue() * 1000);
											synchronized(bwOutputLock) {
												writeToSubProcessStdin(objToCommandeCode(cmdPaSend), 0, true);
											}
										} catch (Exception e) {
											e.printStackTrace();
											process.destroy();
											System.exit(-1);
										}
									}
							}));	
						}
					}
		
					for (CommandeParallelisable commande : commandes) {
						if(commande instanceof CommandeAvecDureeVitesse) {
							CommandeAvecDureeVitesse cmdDureeVitesse = CommandeAvecDureeVitesse.class.cast(commande);
							writeToSubProcessStdin(objToCommandeCode(commande), cmdDureeVitesse.getVitesse().getValue(), false);
						}
					}
					bwOutput.flush();
					
					for (Thread t : threads) {
						t.start();
					}
					
					for (Thread t : threads) {
						t.join();
					}
		
				} catch (Exception e) {
					e.printStackTrace();
					process.destroy();
					System.exit(-1);
				}
			}
			
			
			private void writeToSubProcessStdin(int code, int value, boolean flush) throws IOException {
				StringBuilder sb = new StringBuilder();
				
				sb.append(code);
				sb.append(' ');
				sb.append(value);
				
				bwOutput.write(sb.toString());
				bwOutput.newLine();
				if(flush)
					bwOutput.flush();
			}
			
			private static int objToCommandeCode(CommandeParallelisable commande) {
				Class<?> clazz = commande.getClass();
				if(clazz.equals(Avancer.class)) {
					return AVANCER_INPUT_CODE;
				} else if(clazz.equals(Reculer.class)) {
					return RECULER_INPUT_CODE;
				} else if(clazz.equals(Monter.class)) {
					return MONTER_INPUT_CODE;
				} else if(clazz.equals(Descendre.class)) {
					return DESCENDRE_INPUT_CODE;
				} else if(clazz.equals(Gauche.class)) {
					return GAUCHE_INPUT_CODE;
				} else if(clazz.equals(Droite.class)) {
					return DROITE_INPUT_CODE;
				} else if(clazz.equals(RotationGauche.class)) {
					return ROTATION_GAUCHE_INPUT_CODE;
				} else if(clazz.equals(RotationDroite.class)) {
					return ROTATION_DROITE_INPUT_CODE;
				} else {
					return 0;
				}
			}
		}
		'''
	}
	
	def contentDroneRuntimeExecutableClass() {
		'''
		package fr.roboticiens.runtime;
		
		public interface DroneRuntimeExecutable {
			
			public void execute(DroneRuntime droneRuntime);
		
		}
		'''
	}
	
	def contentDroneRuntimeClass() {
		'''
		package fr.roboticiens.runtime;
		
		import fr.roboticiens.commandes.Atterrir;
		import fr.roboticiens.commandes.Avancer;
		import fr.roboticiens.commandes.Decoller;
		import fr.roboticiens.commandes.Descendre;
		import fr.roboticiens.commandes.Droite;
		import fr.roboticiens.commandes.Gauche;
		import fr.roboticiens.commandes.Monter;
		import fr.roboticiens.commandes.Pause;
		import fr.roboticiens.commandes.Reculer;
		import fr.roboticiens.commandes.RotationDroite;
		import fr.roboticiens.commandes.RotationGauche;
		import fr.roboticiens.paralleles.Parallele;
		import fr.roboticiens.prologue.Prologue;
		
		public interface DroneRuntime {
			
			public void start();
			public void execPrologue(Prologue p);
			
			public void execDecoller(Decoller d);
			public void execAtterrir(Atterrir a);
			
			public void execAvancer(Avancer a);
			public void execReculer(Reculer r);
			public void execMonter(Monter m);
			public void execDescendre(Descendre d);
			public void execGauche(Gauche g);
			public void execDroite(Droite d);
			public void execRotationGauche(RotationGauche rg);
			public void execRotationDroite(RotationDroite rd);
			public void execPause(Pause p);
			public void quit();
			
			public void execParallele(Parallele p);
			
		}
		'''
	}
	
	def contentSecondeClass() {
		'''
		package fr.roboticiens.types;
		
		public class Seconde {
			
			private final int value;
		
			public Seconde(final int value) {
				this.value = value;
			}
		
			/**
			 * @return the value
			 */
			public Integer getValue() {
				return value;
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Seconde [value=" + value + "]";
			}
			
		}
		'''
	}
	
	def contentPourcentClass() {
		'''
		package fr.roboticiens.types;
		
		public class Pourcent {
			
			private final int value;
		
			public Pourcent(final int value) {
				this.value = value;
			}
		
			/**
			 * @return the value
			 */
			public Integer getValue() {
				return value;
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Pourcent [value=" + value + "]";
			}
		
		}
		'''
	}
	
	def contentPrologueClass() {
		'''
		package fr.roboticiens.prologue;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.runtime.DroneRuntime;
		import fr.roboticiens.runtime.DroneRuntimeExecutable;
		
		public class Prologue implements DroneRuntimeExecutable {
			
			private final Pourcent vitesseVerticale;
			private final Pourcent vitesseDeplacement;
			private final Pourcent vitesseRotation;
			private final int hauteurMax;
			private final int eloignementMax;
			
			public Prologue(final Pourcent vitesseVerticale, final Pourcent vitesseDeplacement, 
					final Pourcent vitesseRotation, final int hauteurMax, final int eloignementMax) {
				
				this.vitesseVerticale = vitesseVerticale;
				this.vitesseDeplacement = vitesseDeplacement;
				this.vitesseRotation = vitesseRotation;
				this.hauteurMax = hauteurMax;
				this.eloignementMax = eloignementMax;
			}
		
			/**
			 * @return the vitesseVerticale
			 */
			public Pourcent getVitesseVerticale() {
				return vitesseVerticale;
			}
		
			/**
			 * @return the vitesseDeplacement
			 */
			public Pourcent getVitesseDeplacement() {
				return vitesseDeplacement;
			}
		
			/**
			 * @return the vitesseRotation
			 */
			public Pourcent getVitesseRotation() {
				return vitesseRotation;
			}
		
			/**
			 * @return the hauteurMax
			 */
			public int getHauteurMax() {
				return hauteurMax;
			}
		
			/**
			 * @return the eloignementMax
			 */
			public int getEloignementMax() {
				return eloignementMax;
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execPrologue(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Prologue [vitesseVerticale=" + vitesseVerticale + ", vitesseDeplacement=" + vitesseDeplacement + ", vitesseRotation=" + vitesseRotation + ", hauteurMax="
						+ hauteurMax + ", eloignementMax=" + eloignementMax + "]";
			}
		}
		'''
	}
	
	def contentParalleleClass() {
		'''
		package fr.roboticiens.paralleles;
		
		import java.util.HashSet;
		import java.util.Set;
		
		import fr.roboticiens.body.BodyInstruction;
		import fr.roboticiens.commandes.CommandeParallelisable;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Parallele implements BodyInstruction {
			
			private Set<CommandeParallelisable> commandes;
			
			public Parallele() {
				this.commandes = new HashSet<CommandeParallelisable>();
			}
			
			public boolean addCommande(final CommandeParallelisable cp) {
				return commandes.add(cp);
			}
		
			/**
			 * @return the commandes
			 */
			public Set<CommandeParallelisable> getCommandes() {
				return commandes;
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execParallele(this);
			}
		
			@Override
			public String toString() {
				String tmp = "Parallele" + commandes.size() + " [\n";
				for (CommandeParallelisable e : commandes) {
					tmp += "\t" + e.toString() + "\n";
				}
				tmp += "]";
				return tmp;
			}
		}
		'''
	}
	
	def contentImportClass() {
		'''
		package fr.roboticiens.imports;
		
		public class Import {
			
			private final String filename;
		
			public Import(final String filename) {
				super();
				this.filename = filename;
			}
		
			/**
			 * @return the filename
			 */
			public String getFilename() {
				return filename;
			}
			
		}
		'''
	}
	
	def contentRotationGaucheClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.types.Seconde;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class RotationGauche extends CommandeAvecDureeVitesse implements CommandeBasique, CommandeParallelisable {
		
			public RotationGauche(final Seconde duree, final Pourcent vitesse) {
				super(duree, vitesse);
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execRotationGauche(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "RotationGauche [duree=" + duree + ", vitesse=" + vitesse + "]";
			}
		
		}
		'''
	}
	
	def contentRotationDroiteClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.types.Seconde;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class RotationDroite extends CommandeAvecDureeVitesse implements CommandeBasique, CommandeParallelisable {
		
			public RotationDroite(final Seconde duree, final Pourcent vitesse) {
				super(duree, vitesse);
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execRotationDroite(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "RotationDroite [duree=" + duree + ", vitesse=" + vitesse + "]";
			}
		
		}
		'''
	}
	
	def contentReculerClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.types.Seconde;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Reculer extends CommandeAvecDureeVitesse implements CommandeBasique, CommandeParallelisable {
		
			public Reculer(final Seconde duree, final Pourcent vitesse) {
				super(duree, vitesse);
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execReculer(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Reculer [duree=" + duree + ", vitesse=" + vitesse + "]";
			}
		
		}
		'''
	}
	
	def contentPauseClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Seconde;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Pause implements CommandeBasique {
			
			protected final Seconde duree;
			
			public Pause(final Seconde duree) {
				this.duree = duree;
			}
		
			/**
			 * @return the duree
			 */
			public Seconde getDuree() {
				return duree;
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execPause(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Pause [duree=" + duree + "]";
			}
			
		}
		'''
	}
	
	def contentMonterClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.types.Seconde;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Monter extends CommandeAvecDureeVitesse implements CommandeBasique, CommandeParallelisable {
		
			public Monter(final Seconde duree, final Pourcent vitesse) {
				super(duree, vitesse);
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execMonter(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Monter [duree=" + duree + ", vitesse=" + vitesse + "]";
			}
			
		}
		'''
	}
	
	def contentGaucheClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.types.Seconde;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Gauche extends CommandeAvecDureeVitesse implements CommandeBasique, CommandeParallelisable {
		
			public Gauche(final Seconde duree, final Pourcent vitesse) {
				super(duree, vitesse);
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execGauche(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Gauche [duree=" + duree + ", vitesse=" + vitesse + "]";
			}
			
		}
		'''
	}
	
	def contentDroiteClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.types.Seconde;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Droite extends CommandeAvecDureeVitesse implements CommandeBasique, CommandeParallelisable {
		
			public Droite(final Seconde duree, final Pourcent vitesse) {
				super(duree, vitesse);
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execDroite(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Droite [duree=" + duree + ", vitesse=" + vitesse + "]";
			}
			
		}
		'''
	}
	
	def contentDescendreClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.types.Seconde;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Descendre extends CommandeAvecDureeVitesse implements CommandeBasique, CommandeParallelisable {
		
			public Descendre(final Seconde duree, final Pourcent vitesse) {
				super(duree, vitesse);
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execDescendre(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Descendre [duree=" + duree + ", vitesse=" + vitesse + "]";
			}
			
		}
		'''
	}
	
	def contentDecollerClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Decoller implements CommandeBasique {
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execDecoller(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Decoller []";
			}
		
		}
		'''
	}
	
	def contentCommandeParallelisableClass() {
		'''
		package fr.roboticiens.commandes;
		
		public interface CommandeParallelisable {
		
		}
		'''
	}
	
	def contentCommandeBasiqueClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.body.BodyInstruction;
		
		public interface CommandeBasique extends BodyInstruction {
		
		}
		'''
	}
	
	def contentCommandeAvecDureeVitesseClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.types.Seconde;
		
		public abstract class CommandeAvecDureeVitesse {
			
			protected final Seconde duree;
			protected final Pourcent vitesse;
			
			public CommandeAvecDureeVitesse(final Seconde duree, final Pourcent vitesse) {
				this.duree = duree;
				this.vitesse = vitesse;
			}
		
			/**
			 * @return the duree
			 */
			public Seconde getDuree() {
				return duree;
			}
		
			/**
			 * @return the vitesse
			 */
			public Pourcent getVitesse() {
				return vitesse;
			}
		
		}
		'''
	}
	
	def contentAvancerClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.types.Pourcent;
		import fr.roboticiens.types.Seconde;
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Avancer extends CommandeAvecDureeVitesse implements CommandeBasique, CommandeParallelisable {
		
			public Avancer(final Seconde duree, final Pourcent vitesse) {
				super(duree, vitesse);
			}
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execAvancer(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Avancer [duree=" + duree + ", vitesse=" + vitesse + "]";
			}
			
		}
		'''
	}
	
	def contentAtterrirClass() {
		'''
		package fr.roboticiens.commandes;
		
		import fr.roboticiens.runtime.DroneRuntime;
		
		public class Atterrir implements CommandeBasique {
		
			@Override
			public void execute(DroneRuntime droneRuntime) {
				droneRuntime.execAtterrir(this);
			}
		
			/* (non-Javadoc)
			 * @see java.lang.Object#toString()
			 */
			@Override
			public String toString() {
				return "Atterrir []";
			}
			
		}
		'''
	}
	
	def contentBodyInstructionClass() {
		'''
		package fr.roboticiens.body;
		
		import fr.roboticiens.runtime.DroneRuntimeExecutable;
		
		public interface BodyInstruction extends DroneRuntimeExecutable {
		
		}
		'''
	}
	
}
